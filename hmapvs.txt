#version 150

in vec2 a_position;


uniform mat4 viewMatrix;
uniform mat4 projMatrix;
uniform sampler2D htex;
uniform vec3 Min, Max;
uniform vec2 resolution;    //texture resolution. Need float for float division.
                            //Could also use textureSize and convert to float.
uniform float recip;

out vec3 v_pw;
out vec3 v_normal;
out  vec2 debug;

vec3 point(vec2 coord){
    ivec2 c1 = ivec2(coord);

    ivec2 patchnum = c1 / ivec2(4);
    ivec2 patchorigin = patchnum * ivec2(4);
    vec2 uv = (coord - patchorigin)/4.0;
debug=uv;

    vec4 U = vec4(uv[0]*uv[0]*uv[0], uv[0]*uv[0], uv[0], 1);
    vec4 V = vec4(uv[1]*uv[1]*uv[1], uv[1]*uv[1], uv[1], 1);

    /*
    //Bezier
    float C[16];
    C[0] = texelFetch( htex, patchorigin, 0 ).r;
    C[1] = texelFetch( htex, ivec2(patchorigin.x+1,patchorigin.y), 0 ).r;
    C[2] = texelFetch( htex, ivec2(patchorigin.x+2,patchorigin.y), 0 ).r;
    C[3] = texelFetch( htex, ivec2(patchorigin.x+3,patchorigin.y), 0 ).r;
    C[4] = texelFetch( htex, ivec2(patchorigin.x,  patchorigin.y+1), 0 ).r;
    C[5] = texelFetch( htex, ivec2(patchorigin.x+1,patchorigin.y+1), 0 ).r;
    C[6] = texelFetch( htex, ivec2(patchorigin.x+2,patchorigin.y+1), 0 ).r;
    C[7] = texelFetch( htex, ivec2(patchorigin.x+3,patchorigin.y+1), 0 ).r;
    C[8] = texelFetch( htex, ivec2(patchorigin.x,  patchorigin.y+2), 0 ).r;
    C[9] = texelFetch( htex, ivec2(patchorigin.x+1,patchorigin.y+2), 0 ).r;
    C[10]= texelFetch( htex, ivec2(patchorigin.x+2,patchorigin.y+2), 0 ).r;
    C[11]= texelFetch( htex, ivec2(patchorigin.x+3,patchorigin.y+2), 0 ).r;
    C[12]= texelFetch( htex, ivec2(patchorigin.x,  patchorigin.y+3), 0 ).r;
    C[13]= texelFetch( htex, ivec2(patchorigin.x+1,patchorigin.y+3), 0 ).r;
    C[14]= texelFetch( htex, ivec2(patchorigin.x+2,patchorigin.y+3), 0 ).r;
    C[15]= texelFetch( htex, ivec2(patchorigin.x+3,patchorigin.y+3), 0 ).r;

    //column major
    mat4 M = mat4(  -1, 3,  -3, 1,  
                    3,  -6, 3,  0,
                    -3, 3,  0,  0,
                    1,  0,  0,  0);

    mat4 P = mat4( 
            C[0] ,C[4] ,C[8] ,C[12] ,
            C[1] ,C[5] ,C[9] ,C[13] ,
            C[2] ,C[6] ,C[10] ,C[14] ,
            C[3] ,C[7] ,C[11] ,C[15] );

    float y = dot(U*M*P*transpose(M),V);
*/

    //linear
    float nw = texelFetch( htex, c1.xy,0).r;
    float ne = texelFetch( htex, ivec2(c1.x+1,c1.y),0).r;
    float sw = texelFetch( htex, ivec2(c1.x,c1.y+1),0).r;
    float se = texelFetch( htex, ivec2(c1.x+1,c1.y+1),0).r;
    float t = fract(coord.x);
    float n = mix(nw,ne,t);
    float s = mix(sw,se,t);
    t = fract(coord.y);
    float y = mix(n,s,t);


    //Catmull-Rom

    vec2 tmp = coord / resolution;
    return Min + vec3(tmp[0],y,tmp[1]) * (Max-Min);
}
void main(){

//ivec2 patchnum = ivec2(a_position) / ivec2(4);
//debug = patchnum;

    vec2 pos = a_position;
    vec3 east = point( pos + vec2(recip,0));
    vec3 south = point( pos + vec2(0,recip));
    vec3 north = point( pos + vec2(0,-recip));
    vec3 west = point( pos + vec2(-recip,0));

    vec3 p = point(pos);
    v_pw = p.xyz;

    vec3 v1 = (east-p).xyz;
    vec3 v2 = (south-p).xyz;
    vec3 v3 = (west-p).xyz;
    vec3 v4 = (north-p).xyz;
    vec3 cp1 = cross(v2,v1);
    vec3 cp2 = cross(v4,v3);
    v_normal = 0.5*(cp1+cp2);
    gl_Position = vec4(p,1.0) * viewMatrix * projMatrix;
}
    

    
