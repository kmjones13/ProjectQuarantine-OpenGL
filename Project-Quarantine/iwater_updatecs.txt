#version 430

layout(local_size_x=32,local_size_y=32,local_size_z=1) in;


//previous, current, next step values. rgb=normal; a=height
layout(std430,binding=0) buffer P{
    vec4 prev[];
};
layout(std430,binding=1) buffer C{
    vec4 curr[];
};
layout(std430,binding=2) buffer N{
    vec4 next[];
};

//precomputed constants
uniform vec4 taus;

//num rows, num columns in prev,curr,next
uniform ivec2 resolution;

//constant for computation
uniform float d;

//x,deltay,z
uniform vec3 ripplepos;

uniform float ripplepower;
uniform float rippledist;
uniform vec2 sz;    //size of mesh
uniform vec2 sz2;

uniform mat4 worldMatrix;


int index(int row, int col){
    return row*resolution[0]+col;
}

void main(){
    vec3 myId = gl_GlobalInvocationID;
    ivec2 myidx = ivec2(myId.xy);
    int row = myidx[0];
    int col = myidx[1];
    
    vec4 tmp;
    
    //h(i-1,j) ; h(i+1,j) ; h(i,j-1) ; h(i,j+1) ; h'(i,j) ; h(i,j)
    float him1j,hip1j,hijm1,hijp1,h_ij,hij;
    
    //get neighboring values; if we fall off edge of buffer, use constant zero
    
    //west
    if( col <= 0 )              him1j = 0.0;
    else                         him1j = curr[ index(row,col-1) ].a;
        
    //east
    if( col >= resolution[1] )  hip1j = 0.0;
    else                        hip1j = curr[index(row,col+1)].a;
        
    //south
    if( row <= 0 )              hijm1 = 0.0;
    else                        hijm1 = curr[ index(row+1,col) ].a;
        
    //north
    if( row >= resolution[0] )  hijp1 = 0.0;
    else                        hijp1 = curr[index(row-1,col)].a;
        
    h_ij = prev[index(row,col)].a;
    hij = curr[index(row,col)].a;
    
    float psi = him1j + hijm1 + hip1j + hijp1;
    float newy = (psi*taus[0] + h_ij*taus[1] + hij*taus[2]) / taus[3];
    
    float pctz = row * 1.0 / resolution[0];
    float pctx = col * 1.0 / resolution[1];
    vec2 pct = vec2(pctx,pctz);
    vec4 pw;
    pw.xz = -sz2 + pct * sz;
    pw.y = 0;
    pw.w = 1.0;
    pw = pw * worldMatrix;

    float delta = 1.0 - length(pw.xz-ripplepos.xz) / rippledist;
    delta = clamp(delta,0.0,1.0);
    delta = pow(delta, ripplepower );
    newy += ripplepos.y * delta;
    
    vec3 N = vec3( ( him1j-hip1j ) / (2.0*d) , 1.0 , (hijm1-hijp1)/(2.0*d) );
   
    N=normalize(N);
    
    next[index(row,col)] = vec4(N.xyz,newy);
}